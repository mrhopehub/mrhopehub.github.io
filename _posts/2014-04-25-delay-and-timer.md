---
layout: posts
title: "计算机中的延时与定时"
---

# {{ page.title }}
>### 简介
刚开始接触51单片机的时候，每天注意延时，看着教材上都是通过指令执行时间来起到延时。再到学习windows程序设计中的，windows的消息循环中有个WM_TIMER，程序会定时的接收到WM_TIMER消息。<br><br>
但是由51单片机转向STM32的阶段时，做跑马灯实验的时候，一直把跑马灯当做定时来实现的（简单的跑马灯：定时完成就toggle LED），然后就一直想着中断，通过timer中断来实现。其实跑马灯通过timer中断来实现是完全可以的（在timer中断例程中toggle LED），而网上找了一下跑马灯的实现多是通过SysTick来实现的。当时对之前的延时、定时概念瞬间就模糊了。所以这里总结、对比一下延时与定时。
>### 延时
>>1.单片机时代查询计算指令的时钟周期，然后计算循环的总时钟周期来实现延时。<br><br>
2.arm时代C程序成为主流的开发语言，通过计算时钟周期来延时不太如何实际。所以延时出现了新的方法。这里借鉴一下操作系统中“时间片”的概念，延时可以通过时间片实现，比如说时间片的长度是1ms，那么延时1s其实就是循环检查剩余的时间片，如果时间片为零则代表延时结束。代码：<br>
<blockquote><blockquote>
<xmp class="prettyprint linenums">
	/*设置延时delay_time，单位时间片（比如1ms、100us等等）*/
	int delay_time=1000;
	while(delay_time);
	/*延时结束,就绪执行*/
</xmp>
</blockquote></blockquote>
>>代码很简单，但是这里有一个问题：经过一个时间片之后，在哪里更新剩余时间片呢（也就是“delay_time--;”放在什么地方呢）？很明显在中断例程中实现，设置什么中断呢？timer中断、SysTick中断。这两者都可以，按照惯例SysTick是作为操作系统的时钟的，所以由SysTick中断例程来更新剩余时间片。<br><br>
>>3.操作系统的延时，比如linux中的sleep(10)。由于操作系统有了进程的概念，所以这里的延时是通过进程调度来实现的，在延时结束时，内核把进程设置为“就绪”状态。需要注意的是，操作系统的延时与前面两种的区别，前面两种延时中检查剩余时间片的代码一直运行在cpu，而操作系统的延时中CPU运行着其他的代码。

>### 定时
>>1.timer定时，从stm32的定时器说起吧，这里的定时指的是：设置timer还有相关的中断。就是这么简单，但要认识到的是这里的定时是与中断关联在一起的，而且在中断到来之前CPU是在进行其他计算的。<br><br>
2.操作系统消息式定时，那windows消息来说，程序设置了timer之后，操作系统会维护这个timer，在这个timer结束之后，操作系统就会给进程发送WM_TIMER消息。

>### 延时与定时小结
>>1.延时强调的是代码一直在等待时间结束，有polling的意味（虽然操作系统的延时通过进程切换实现，但是在时钟中断例程中还是要检查进程的剩余时间片，归根结底也是polling。<br><br>
2.相反定时强调的是不用等待时间结束，有interrupt的意味（其实消息式定时是靠polling实现的）。
